// @generated by protoc-gen-es v2.11.0 with parameter "target=js+dts"
// @generated from file bridge/v1/bridge.proto (package bridge.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message as Message$1 } from "@bufbuild/protobuf";

/**
 * Describes the file bridge/v1/bridge.proto.
 */
export declare const file_bridge_v1_bridge: GenFile;

/**
 * @generated from message bridge.v1.ServerConnection
 */
export declare type ServerConnection = Message$1<"bridge.v1.ServerConnection"> & {
  /**
   * The URL for sandbox. This needs to be validated to be *.vercel.run.
   *
   * @generated from field: string sandbox_url = 1 [json_name = "sandbox_url"];
   */
  sandboxUrl: string;

  /**
   * The connection key generated by the sandbox for tunnel pairing.
   *
   * @generated from field: string connection_key = 2 [json_name = "connection_key"];
   */
  connectionKey: string;
};

/**
 * Describes the message bridge.v1.ServerConnection.
 * Use `create(ServerConnectionSchema)` to create a new message.
 */
export declare const ServerConnectionSchema: GenMessage<ServerConnection>;

/**
 * Message is the unit of communication through the tunnel.
 * The first message MUST contain a Registration to identify the connection.
 * Subsequent messages contain data to be relayed to the peer.
 *
 * @generated from message bridge.v1.Message
 */
export declare type Message = Message$1<"bridge.v1.Message"> & {
  /**
   * Registration is only sent on the first message to register with bridge.
   *
   * @generated from field: optional bridge.v1.Message.Registration registration = 1;
   */
  registration?: Message_Registration;

  /**
   * The address that is sending the message.
   *
   * @generated from field: bridge.v1.Message.Address source = 2;
   */
  source?: Message_Address;

  /**
   * The intended target address on the destination.
   *
   * @generated from field: bridge.v1.Message.Address dest = 3;
   */
  dest?: Message_Address;

  /**
   * The payload data being tunneled.
   *
   * @generated from field: bytes data = 4;
   */
  data: Uint8Array;

  /**
   * Connection ID for multiplexing multiple connections over one tunnel.
   * Each unique source+dest pair represents a logical connection.
   *
   * @generated from field: string connection_id = 5 [json_name = "connection_id"];
   */
  connectionId: string;

  /**
   * Set to true when the connection should be closed.
   *
   * @generated from field: bool close = 6;
   */
  close: boolean;

  /**
   * Error message if something went wrong.
   *
   * @generated from field: string error = 7;
   */
  error: string;

  /**
   * DNS query resolution request, sent from intercept to dispatcher via the tunnel.
   *
   * @generated from field: optional bridge.v1.ResolveDNSQueryRequest dns_request = 8 [json_name = "dns_request"];
   */
  dnsRequest?: ResolveDNSQueryRequest;

  /**
   * DNS query resolution response, sent from dispatcher back to intercept via the tunnel.
   *
   * @generated from field: optional bridge.v1.ResolveDNSQueryResponse dns_response = 9 [json_name = "dns_response"];
   */
  dnsResponse?: ResolveDNSQueryResponse;
};

/**
 * Describes the message bridge.v1.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export declare const MessageSchema: GenMessage<Message>;

/**
 * @generated from message bridge.v1.Message.Address
 */
export declare type Message_Address = Message$1<"bridge.v1.Message.Address"> & {
  /**
   * @generated from field: string ip = 1;
   */
  ip: string;

  /**
   * @generated from field: int32 port = 2;
   */
  port: number;
};

/**
 * Describes the message bridge.v1.Message.Address.
 * Use `create(Message_AddressSchema)` to create a new message.
 */
export declare const Message_AddressSchema: GenMessage<Message_Address>;

/**
 * @generated from message bridge.v1.Message.Registration
 */
export declare type Message_Registration = Message$1<"bridge.v1.Message.Registration"> & {
  /**
   * If true, this is a server (Vercel proxy function).
   * If false, this is a client (local tunnel CLI).
   *
   * @generated from field: bool is_server = 1 [json_name = "is_server"];
   */
  isServer: boolean;

  /**
   * The protocol used for the connection (TCP or UDP).
   *
   * @generated from field: bridge.v1.Message.Protocol protocol = 2;
   */
  protocol: Message_Protocol;

  /**
   * The URL of the proxy function that bridge should connect to.
   * Only set by clients (is_server=false). Tunneld will open a
   * Connect stream to this URL to establish the server-side connection.
   *
   * @generated from field: string function_url = 3 [json_name = "function_url"];
   */
  functionUrl: string;

  /**
   * The Vercel deployment protection bypass secret (optional).
   *
   * @generated from field: string protection_bypass_secret = 4 [json_name = "protection_bypass_secret"];
   */
  protectionBypassSecret: string;
};

/**
 * Describes the message bridge.v1.Message.Registration.
 * Use `create(Message_RegistrationSchema)` to create a new message.
 */
export declare const Message_RegistrationSchema: GenMessage<Message_Registration>;

/**
 * @generated from enum bridge.v1.Message.Protocol
 */
export enum Message_Protocol {
  /**
   * @generated from enum value: PROTOCOL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: PROTOCOL_TCP = 1;
   */
  TCP = 1,

  /**
   * @generated from enum value: PROTOCOL_UDP = 2;
   */
  UDP = 2,
}

/**
 * Describes the enum bridge.v1.Message.Protocol.
 */
export declare const Message_ProtocolSchema: GenEnum<Message_Protocol>;

/**
 * ResolveDNSQueryRequest is sent by the intercept client through the tunnel
 * to ask the dispatcher to resolve a hostname.
 *
 * @generated from message bridge.v1.ResolveDNSQueryRequest
 */
export declare type ResolveDNSQueryRequest = Message$1<"bridge.v1.ResolveDNSQueryRequest"> & {
  /**
   * Unique ID to correlate this request with its response.
   *
   * @generated from field: string request_id = 1 [json_name = "request_id"];
   */
  requestId: string;

  /**
   * The hostname to resolve (e.g., "api.example.com").
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;
};

/**
 * Describes the message bridge.v1.ResolveDNSQueryRequest.
 * Use `create(ResolveDNSQueryRequestSchema)` to create a new message.
 */
export declare const ResolveDNSQueryRequestSchema: GenMessage<ResolveDNSQueryRequest>;

/**
 * ResolveDNSQueryResponse is sent by the dispatcher back through the tunnel
 * with the resolved IP addresses for a DNS query.
 *
 * @generated from message bridge.v1.ResolveDNSQueryResponse
 */
export declare type ResolveDNSQueryResponse = Message$1<"bridge.v1.ResolveDNSQueryResponse"> & {
  /**
   * The request_id from the corresponding ResolveDNSQueryRequest.
   *
   * @generated from field: string request_id = 1 [json_name = "request_id"];
   */
  requestId: string;

  /**
   * The resolved IPv4 addresses.
   *
   * @generated from field: repeated string addresses = 2;
   */
  addresses: string[];

  /**
   * Error message if resolution failed.
   *
   * @generated from field: string error = 3;
   */
  error: string;
};

/**
 * Describes the message bridge.v1.ResolveDNSQueryResponse.
 * Use `create(ResolveDNSQueryResponseSchema)` to create a new message.
 */
export declare const ResolveDNSQueryResponseSchema: GenMessage<ResolveDNSQueryResponse>;


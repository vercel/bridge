syntax = "proto3";

package bridge.v1;

// BridgeProxyService runs in-cluster and provides DNS resolution and network
// tunneling to the local bridge intercept client over gRPC.
service BridgeProxyService {
  // ResolveDNSQuery resolves a hostname using the in-cluster DNS (CoreDNS).
  // buf:lint:ignore RPC_REQUEST_STANDARD_NAME
  // buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
  rpc ResolveDNSQuery(ProxyResolveDNSRequest) returns (ProxyResolveDNSResponse);

  // TunnelNetwork tunnels TCP/UDP traffic to an upstream service over a
  // bidirectional stream. Every message carries source/dest addresses and a
  // connection ID so both sides share the same addressing semantics as the
  // WebSocket Message in bridge.proto.
  // buf:lint:ignore RPC_REQUEST_STANDARD_NAME
  // buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
  // buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
  rpc TunnelNetwork(stream TunnelNetworkMessage) returns (stream TunnelNetworkMessage);
}

message ProxyResolveDNSRequest {
  string hostname = 1;
}

message ProxyResolveDNSResponse {
  repeated string addresses = 1;
  string error = 2;
}

enum TunnelProtocol {
  TUNNEL_PROTOCOL_UNSPECIFIED = 0;
  TUNNEL_PROTOCOL_TCP = 1;
  TUNNEL_PROTOCOL_UDP = 2;
}

message TunnelAddress {
  string ip = 1;
  int32 port = 2;
}

message TunnelNetworkMessage {
  // The address that is sending the message.
  TunnelAddress source = 1;

  // The intended target address on the destination.
  TunnelAddress dest = 2;

  // Connection ID for multiplexing multiple connections over one stream.
  string connection_id = 3 [json_name = "connection_id"];

  // The payload data being tunneled.
  bytes data = 4;

  // The protocol used for the connection (TCP or UDP).
  TunnelProtocol protocol = 5;

  // Error message if something went wrong.
  string error = 6;
}
